/// <reference path="../../adonis-typings/session.d.ts" />
import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext';
import { SessionConfig, SessionContract, AllowedSessionValues, SessionDriverContract } from '@ioc:Adonis/Addons/Session';
import { Store } from '../Store';
/**
 * Session class exposes the API to read/write values to the session for
 * a given request.
 */
export declare class Session implements SessionContract {
    private ctx;
    private config;
    private driver;
    /**
     * Set to true inside the `initiate` method
     */
    initiated: boolean;
    /**
     * A boolean to know if it's a fresh session or not. Fresh
     * sessions are those, whose session id is not present
     * in cookie
     */
    fresh: boolean;
    /**
     * A boolean to know if store is initiated in readonly mode
     * or not. This is done during Websocket requests
     */
    readonly: boolean;
    /**
     * Session id for the given request. A new session id is only
     * generated when the cookie for the session id is missing
     */
    sessionId: string;
    /**
     * A copy of previously set flash messages
     */
    flashMessages: Store;
    /**
     * Session id for the current request. It will be different
     * from the "this.sessionId" when regenerate is called.
     */
    private currentSessionId;
    /**
     * A instance of store with values read from the driver. The store
     * in initiated inside the [[initiate]] method
     */
    private store;
    /**
     * Whether or not to re-generate the session id before comitting
     * session values.
     */
    private regeneratedSessionId;
    /**
     * A copy of flash messages. The `input` messages
     * are overwritten when any of the input related
     * methods are used.
     *
     * The `others` object is expanded with each call.
     */
    responseFlashMessages: Store;
    /**
     * Session key for setting flash messages
     */
    private flashMessagesKey;
    constructor(ctx: HttpContextContract, config: SessionConfig, driver: SessionDriverContract);
    /**
     * Returns a merged copy of flash messages or null
     * when nothing is set
     */
    private setFlashMessages;
    /**
     * Returns the existing session id or creates one.
     */
    private getSessionId;
    /**
     * Ensures the session store is initialized
     */
    private ensureIsReady;
    /**
     * Raises exception when session store is in readonly mode
     */
    private ensureIsMutable;
    /**
     * Touches the session cookie
     */
    private touchSessionCookie;
    /**
     * Commits the session value to the store
     */
    private commitValuesToStore;
    /**
     * Touches the driver to make sure the session values doesn't expire
     */
    private touchDriver;
    /**
     * Reading flash messages from the last HTTP request and
     * updating the flash messages bag
     */
    private readLastRequestFlashMessage;
    /**
     * Share flash messages & read only session's functions with views
     * (only when view property exists)
     */
    private shareLocalsWithView;
    /**
     * Initiating the session by reading it's value from the
     * driver and feeding it to a store.
     *
     * Multiple calls to `initiate` results in a noop.
     */
    initiate(readonly: boolean): Promise<void>;
    /**
     * Re-generates the session id. This can is used to avoid
     * session fixation attacks.
     */
    regenerate(): void;
    /**
     * Set/update session value
     */
    put(key: string, value: AllowedSessionValues): void;
    /**
     * Find if the value exists in the session
     */
    has(key: string): boolean;
    /**
     * Get value from the session. The default value is returned
     * when actual value is `undefined`
     */
    get(key: string, defaultValue?: any): any;
    /**
     * Returns everything from the session
     */
    all(): any;
    /**
     * Remove value for a given key from the session
     */
    forget(key: string): void;
    /**
     * The method is equivalent to calling `session.get` followed
     * by `session.forget`
     */
    pull(key: string, defaultValue?: any): any;
    /**
     * Increment value for a number inside the session store. The
     * method raises an error when underlying value is not
     * a number
     */
    increment(key: string, steps?: number): void;
    /**
     * Decrement value for a number inside the session store. The
     * method raises an error when underlying value is not
     * a number
     */
    decrement(key: string, steps?: number): void;
    /**
     * Remove everything from the session
     */
    clear(): void;
    /**
     * Add a new flash message
     */
    flash(key: string | {
        [key: string]: AllowedSessionValues;
    }, value?: AllowedSessionValues): void;
    /**
     * Flash all form values
     */
    flashAll(): void;
    /**
     * Flash all form values except mentioned keys
     */
    flashExcept(keys: string[]): void;
    /**
     * Flash only defined keys from the form values
     */
    flashOnly(keys: string[]): void;
    /**
     * Reflash existing flash messages
     */
    reflash(): void;
    /**
     * Reflash selected keys from the existing flash messages
     */
    reflashOnly(keys: string[]): void;
    /**
     * Omit selected keys from the existing flash messages
     * and flash the rest of values
     */
    reflashExcept(keys: string[]): void;
    /**
     * Writes value to the underlying session driver.
     */
    commit(): Promise<void>;
}
